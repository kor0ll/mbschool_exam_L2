package pattern

import "fmt"

/*
	Реализовать паттерн «стратегия».
Объяснить применимость паттерна, его плюсы и минусы, а также реальные примеры использования данного примера на практике.
	https://en.wikipedia.org/wiki/Strategy_pattern
*/
/*
Стратегия — это поведенческий паттерн проектирования, который определяет семейство схожих алгоритмов и помещает каждый из них в собственный класс,
после чего алгоритмы можно взаимозаменять прямо во время исполнения программы.
Этот паттерн применяется в случаях, когда нужно использовать разные вариации какого-то алгоритма внутри объекта, или
когда есть множество похожих классов, отличающихся только некоторым поведением.
Например: есть приложение - навигатор, представленное как структура с методом buildROute для составления маршрута от точки А в точку Б.
Маршруты могут быть разными: автомобильными, пешими, велосипедными и т.д. Чтобы не нагружать класс огромным методом, который неудобно дополнять и поддерживать, можно
воспользоваться паттерном стратегия

Плюсами стратегии являются возможность замены алгоритмов во время исполнения программы, изоляция кода алгоритмов и реализация принципа открытости/закрытости
Минусами являются усложнение кода программы за счет дополнительных классов, а также то, что клиенту необходимо знать различие между стратегиями, чтобы выбрать подходящую
*/

// объявляем общий интерфейс для стратегий с методом buildRoute
type RouteStrategy interface {
	buildRoute(string, string)
}

// Определяем структуру навигатора
type Navigator struct {
	strategy RouteStrategy
}

// buildRoute навигатора будет делегировать обязанности на выбраннюу стратегию
func (n *Navigator) buildRoute(a string, b string) {
	n.strategy.buildRoute(a, b)
}

// определяем функцию для смены стратегий для того, чтобы можно было менять стратегии во время выполнения программы
func (n *Navigator) setStrategy(s RouteStrategy) {
	n.strategy = s
}

// реализуем конкретные структуры стратегий
type RoadStrategy struct {
}

func (r *RoadStrategy) buildRoute(a string, b string) {
	fmt.Println("Автомобильный маршрут построен!")
}

type PublicTransportStrategy struct {
}

func (r *PublicTransportStrategy) buildRoute(a string, b string) {
	fmt.Println("Маршрут для общественного транспорта построен!")
}

type WalkingStrategy struct {
}

func (r *WalkingStrategy) buildRoute(a string, b string) {
	fmt.Println("Пеший маршрут построен!")
}

//таким образом структура навигатора делегирует обязанности на разные стратегии, которые можно менять на лету
